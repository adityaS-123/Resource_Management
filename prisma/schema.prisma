// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  password      String?
  emailVerified DateTime?
  image         String?
  role          Role      @default(USER)
  accounts      Account[]
  sessions      Session[]
  createdProjects Project[] @relation("CreatedProjects")
  assignedProjects Project[] @relation("ProjectUsers")
  resourceRequests ResourceRequest[]
  approvedRequests ResourceRequest[] @relation("ApprovedBy")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Project {
  id             String         @id @default(cuid())
  name           String
  client         String
  startDate      DateTime
  endDate        DateTime
  createdById    String
  createdBy      User           @relation("CreatedProjects", fields: [createdById], references: [id])
  phases         Phase[]
  users          User[]         @relation("ProjectUsers")
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

model Phase {
  id              String            @id @default(cuid())
  name            String
  duration        Int               // in months
  allocatedCost   Float
  projectId       String
  project         Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  resources       Resource[]
  resourceRequests ResourceRequest[]
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
}

model ResourceTemplate {
  id          String          @id @default(cuid())
  name        String          @unique // e.g. "Virtual Machine", "Storage", "Custom Server"
  description String?
  isActive    Boolean         @default(true)
  fields      ResourceField[]
  resources   Resource[]
  resourceRequests ResourceRequest[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
}

model ResourceField {
  id               String           @id @default(cuid())
  name             String           // e.g. "CPU Cores", "RAM", "Custom Field"
  label            String           // Display label
  fieldType        ResourceFieldType
  isRequired       Boolean          @default(false)
  defaultValue     String?
  options          String?          // JSON string for select options
  unit             String?          // e.g. "GB", "cores", "units"
  minValue         Float?
  maxValue         Float?
  resourceTemplateId String
  resourceTemplate ResourceTemplate @relation(fields: [resourceTemplateId], references: [id], onDelete: Cascade)
  sortOrder        Int              @default(0)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
}

model Resource {
  id                 String           @id @default(cuid())
  resourceType       String           @default("General Resource") // e.g. "Virtual Machine", "Database", "Load Balancer" - completely flexible
  resourceTemplateId String?          // Optional - for backward compatibility
  resourceTemplate   ResourceTemplate? @relation(fields: [resourceTemplateId], references: [id])
  configuration      String           // JSON string containing all field values
  quantity           Int              // Total available quantity
  consumedQuantity   Int              @default(0) // Quantity already approved/allocated
  costPerUnit        Float
  phaseId            String
  phase              Phase            @relation(fields: [phaseId], references: [id], onDelete: Cascade)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
}

model ResourceRequest {
  id              String           @id @default(cuid())
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  phaseId         String
  phase           Phase            @relation(fields: [phaseId], references: [id])
  resourceTemplateId String?       // Optional - for template-based requests
  resourceTemplate ResourceTemplate? @relation(fields: [resourceTemplateId], references: [id])
  resourceType    String?          // Optional - for flexible resource requests (e.g., "Custom VM", "Database Instance")
  resourceId      String?          // Optional - links to specific resource for availability tracking
  requestedConfig String           // JSON string containing requested field values
  requestedQty    Int
  justification   String?
  status          RequestStatus    @default(PENDING)
  rejectionReason String?
  createdAt       DateTime         @default(now())
  approvedAt      DateTime?
  approvedById    String?
  approvedBy      User?            @relation("ApprovedBy", fields: [approvedById], references: [id])
  updatedAt       DateTime         @updatedAt
}

enum Role {
  ADMIN
  USER
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ResourceFieldType {
  TEXT
  NUMBER
  SELECT
  BOOLEAN
  EMAIL
  URL
  TEXTAREA
}
